<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phoneme to Viseme Lipsync Mapper</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .output-section {
            margin-top: 30px;
        }

        .output-box {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .viseme-display {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .viseme-item {
            background: #e3f2fd;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            color: #1976d2;
            font-size: 14px;
        }

        .timing-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 13px;
        }

        .legend {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .legend h3 {
            margin-top: 0;
            color: #333;
        }

        .legend-item {
            display: inline-block;
            margin: 5px 10px 5px 0;
            padding: 5px 10px;
            background: #e9ecef;
            border-radius: 15px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó£Ô∏è Phoneme to Viseme Lipsync Mapper</h1>

        <div class="input-section">
            <label for="textInput">Text to Convert:</label>
            <textarea id="textInput"
                placeholder="Enter the text you want to convert to lipsync animation...">The New York Times is an American daily newspaper based in New York City. The New York Times covers domestic, national, and international news, and publishes opinion pieces, investigative reports, and reviews.</textarea>
        </div>

        <div class="input-section">
            <label for="speechRate">Speech Rate:</label>
            <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="1">
            <span id="speechRateValue">1.0</span>
        </div>

        <div class="controls">
            <button id="generateLipsyncBtn">Generate Lipsync Data</button>
            <button id="testSpeechBtn">Test Speech + Animation</button>
            <button id="stopSpeechBtn" disabled>Stop Speech</button>
        </div>

        <div class="legend">
            <h3>Viseme Legend:</h3>
            <div class="legend-item">REST - Neutral mouth position</div>
            <div class="legend-item">A - Open mouth (ah, apple)</div>
            <div class="legend-item">E - Slightly open (eh, bed)</div>
            <div class="legend-item">I - Narrow opening (ee, bit)</div>
            <div class="legend-item">O - Round opening (oh, boat)</div>
            <div class="legend-item">U - Pursed lips (oo, book)</div>
            <div class="legend-item">M - Lips together (m, b, p)</div>
            <div class="legend-item">F - Lip to teeth (f, v)</div>
            <div class="legend-item">L - Tongue tip (l, n, t, d)</div>
            <div class="legend-item">TH - Tongue between teeth (th)</div>
            <div class="legend-item">W - Rounded lips (w, qu)</div>
        </div>

        <div class="output-section">
            <!-- <h3>Generated Viseme Sequence:</h3>
            <div id="visemeDisplay" class="viseme-display"></div> -->

            <!-- <div class="timing-info" id="timingInfo"></div>

            <h3>JSON Animation Data:</h3>
            <div id="jsonOutput" class="output-box"></div>

            <h3>Phaser.js Integration Code:</h3>
            <div id="phaserCode" class="output-box"></div> -->
        </div>
    </div>

    <script type="module">
        let wordToPhonemes = {};
        const phonemeDurations = {
            'vowels': 90,
            'consonants': 45,
            'silence': 40
        };
        // Load phonemes data asynchronously
        async function loadPhonemesData() {
            try {
                const response = await fetch('./phonems.json');
                if (!response.ok) {
                    throw new Error(`Failed to load phonems.json: ${response.status}`);
                }
                wordToPhonemes = await response.json();
                console.log('Phonemes data loaded:', wordToPhonemes);

                // Initialize functionality after data is loaded
                addFunctionality();

                // Generate initial example
                generateLipsync();
            } catch (error) {
                console.error('Error loading phonemes data:', error);
                alert('Failed to load phonemes data. Please make sure phonems.json is accessible.');
            }
        }

        function addFunctionality() {
            document.getElementById('generateLipsyncBtn').addEventListener('click', generateLipsync);
            document.getElementById('testSpeechBtn').addEventListener('click', testSpeechWithAnimation);
            document.getElementById('stopSpeechBtn').addEventListener('click', stopSpeech);
        }

        // Basic English phoneme to viseme mapping
        let phonemeToViseme = await fetch('./phonemeToViseme.json').then(res => res.json())

        const availableVisemes = ["A", "O", "E", "I", "U", "M", "F", "TH", "L", "S", "SH", "REST", "R", "W"]

        // Helper function to categorize phonemes for duration calculation
        function getPhonemeCategory(phoneme) {

            const vowels = ['AH', 'EH', 'IH', 'OH', 'UH', 'AA', 'AE', 'AO', 'AW', 'AY', 'EY', 'IY', 'OW', 'OY', 'UW'];
            const consonants = ['B', 'CH', 'D', 'DH', 'F', 'G', 'HH', 'JH', 'K', 'L', 'M', 'N', 'NG', 'P', 'R', 'S', 'SH', 'T', 'TH', 'V', 'W', 'Y', 'Z', 'ZH'];

            if (!phoneme || phoneme.toLowerCase() === 'silence' || phoneme.toLowerCase() === 'rest') {
                return 'silence';
            }

            if (vowels.includes(phoneme.toUpperCase())) {
                return 'vowels';
            }

            if (consonants.includes(phoneme.toUpperCase())) {
                return 'consonants';
            }

            // Default fallback based on common patterns
            if (phoneme.includes('AH') || phoneme.includes('EH') || phoneme.includes('IH') ||
                phoneme.includes('OH') || phoneme.includes('UH')) {
                return 'vowels';
            }

            return 'consonants';
        }

        let currentUtterance = null;
        let animationData = null;
        let currentVisemeIndex = 0;
        let currentWord = null;
        let wordToVisemeMap = [];
        let isAnimating = false;

        function updateSpeechRateDisplay() {
            document.getElementById('speechRateValue').textContent = document.getElementById('speechRate').value;
        }



        function createWordToVisemeMapping(text) {
            const words = text.toLowerCase().split(/\s+/);
            const mapping = {}
            let charIndex = 0;

            for (let word of words) {
                const wordWithoutPunctuation = word.replace(/[^\w\s]/g, '').toLowerCase()
                const phonemes = wordToPhonemes[wordWithoutPunctuation]
                if (phonemeToViseme[wordWithoutPunctuation]) {

                    const visemes = [];
                    const durations = [];
                    phonemes.forEach(phoneme => {
                        visemes.push(phonemeToViseme[phoneme] || 'REST');
                        const category = getPhonemeCategory(phoneme);
                        durations.push(phonemeDurations[category]);
                    });
                    mapping[charIndex] = {
                        word: word,
                        phonemes: phonemes,
                        visemes: visemes,
                        durations: durations
                    }
                } else {
                    // Fallback for unknown words
                    const letters = wordWithoutPunctuation.split('');
                    const phonemes = [];
                    const visemes = [];
                    const durations = [];
                    for (let i = 0; i < letters.length; i++) {
                        let letter = letters[i];
                        switch (letter.toLowerCase()) {
                            case 'a': phonemes.push('AH'); break;
                            case 'b': phonemes.push('B'); break;
                            case 'c':
                                if (letters[i + 1] === 'h') {
                                    phonemes.push('SH');
                                    i++
                                    break;
                                } else {
                                    phonemes.push('K');
                                    break;
                                }
                            case 'd': phonemes.push('D'); break;
                            case 'e': phonemes.push('EH'); break;
                            case 'f': case 'v': phonemes.push('F'); break;
                            case 'g': phonemes.push('G'); break;
                            case 'h': phonemes.push('REST'); break;
                            case 'i': phonemes.push('IH'); break;
                            case 'j': phonemes.push('REST'); break;
                            case 'k': phonemes.push('K'); break;
                            case 'l': phonemes.push('L'); break;
                            case 'm': phonemes.push('M'); break;
                            case 'n': phonemes.push('N'); break;
                            case 'o': phonemes.push('OH'); break;
                            case 'p': phonemes.push('P'); break;
                            case "q": phonemes.push('K'); break;
                            case 'r': phonemes.push('R'); break;
                            case 's':
                                if (letters[i + 1] === 'h') {
                                    phonemes.push('SH');
                                    i++
                                    break;
                                } else {
                                    phonemes.push('S');
                                    break;
                                }
                            case 't': phonemes.push('T'); break;
                            case 'u': phonemes.push('UH'); break;
                            case 'w': phonemes.push('UH'); break;
                            case 'x': phonemes.push('S'); break;
                            case 'y': phonemes.push('EH'); break;
                            case 'z': phonemes.push('S'); break;

                            default: phonemes.push('REST'); break;
                        }

                        const lastPhonemeAdded = phonemes[phonemes.length - 1]
                        if (phonemes.length > 1 && lastPhonemeAdded == phonemes[phonemes.length - 2]) {
                            phonemes.pop()
                        } else {
                            visemes.push(phonemeToViseme[lastPhonemeAdded] || 'REST');
                            const category = getPhonemeCategory(lastPhonemeAdded);
                            durations.push(phonemeDurations[category]);

                        }



                    }
                    mapping[charIndex] = {
                        word: word,
                        phonemes: phonemes,
                        visemes: visemes,
                        durations: durations
                    }
                }
                charIndex += word.length + 1; // +1 for space
            }

            return mapping;
        }
        window.createWordToVisemeMapping = createWordToVisemeMapping


        function removeConsecutiveDuplicates(arr) {
            if (!arr || arr.length === 0) {
                return [];
            }
            const result = [arr[0]];
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] !== arr[i - 1]) {
                    result.push(arr[i]);
                }
            }
            return result;
        }
        function generateLipsync() {
            const text = document.getElementById('textInput').value;
            const speechRate = parseFloat(document.getElementById('speechRate').value);

            if (!text.trim()) {
                alert('Please enter some text to convert.');
                return;
            }

            // Create word to viseme mapping for real-time sync
            wordToVisemeMap = createWordToVisemeMapping(text);
            console.log('Word to Viseme Mapping:', wordToVisemeMap);





        }










        function testSpeechWithAnimation() {
            const text = document.getElementById('textInput').value;
            const speechRate = parseFloat(document.getElementById('speechRate').value);

            if (!text.trim()) {
                alert('Please enter some text to speak.');
                return;
            }

            // Make sure we have generated the lipsync data
            if (!wordToVisemeMap.length) {
                generateLipsync();
            }

            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.rate = speechRate;
            currentUtterance.lang = "en-US";






            window.currentUtterance = currentUtterance

            currentVisemeIndex = 0;
            isAnimating = true;

            currentUtterance.onstart = () => {
                document.getElementById('testSpeechBtn').disabled = true;
                document.getElementById('stopSpeechBtn').disabled = false;
                console.log('Speech and animation started');
            };



            currentUtterance.onboundary = (event) => {
                console.log(event.charIndex, event.name)

                if (event.name === 'word') {
                    animateWordInMouth(wordToVisemeMap[event.charIndex])
                } else {
                    animateWordInMouth(null)
                }



            };

            currentUtterance.onend = () => {
                document.getElementById('testSpeechBtn').disabled = false;
                document.getElementById('stopSpeechBtn').disabled = true;
                isAnimating = false;

                console.log('Speech and animation ended');
            };


            console.log('Current utterance:', currentUtterance);

            speechSynthesis.speak(currentUtterance);
        }



        function stopSpeech() {
            if (currentUtterance) {
                speechSynthesis.cancel();
                document.getElementById('testSpeechBtn').disabled = false;
                document.getElementById('stopSpeechBtn').disabled = true;
            }
        }

        // Initialize  
        document.getElementById('speechRate').addEventListener('input', updateSpeechRateDisplay);
        updateSpeechRateDisplay();
        loadPhonemesData();

    </script>



    <script>
        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,
            width: 400,
            height: 400,
            parent: 'phaser-game',
            backgroundColor: '#34495e',
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };
        let mouthSprite;
        let scene;

        function preload() {
            scene = this;

            // Load all mouth textures
            const visemes = ['a', 'e', 'f', 'l', 'm', 'o', 'r', 's', 'sh', 'th', 'u', "rest"];

            visemes.forEach(viseme => {
                this.load.image(`mouth_${viseme}`, `./mouths/${viseme}.png`);
            });


        }

        function create() {
            mouthSprite = this.add.sprite(200, 200, 'mouth_rest');

        }
        function updateMouth(viseme) {
            // Convert viseme to lowercase to match our texture names
            const visemeKey = viseme.toLowerCase();

            // Check if the texture exists before setting it
            console.log(visemeKey)

            mouthSprite.setTexture(`mouth_${visemeKey}`);

        }

        function update() {

        }
        let arrOfTimeOuts = []

        function animateWordInMouth(word) {

            let currentVisemeIndex = 0;

            for (let i = 0; i < arrOfTimeOuts.length; i++) {
                clearTimeout(arrOfTimeOuts[i])
            }
            arrOfTimeOuts = []
            console.log(word)

            if (!word) {
                updateMouth("rest")
                return
            }


            let totalDuration = word.durations[0]

            updateMouth(word.visemes[0])
            for (let i = 1; i < word.visemes.length; i++) {

                const timeoutObj = setTimeout(() => {
                    updateMouth(word.visemes[i])
                }, totalDuration)

                arrOfTimeOuts.push(timeoutObj)
                totalDuration += word.durations[i] / currentUtterance.rate
            }
            setTimeout(() => {
                updateMouth("rest")
            }, totalDuration)


            /*
            durations: Array [ 80, 120 ]
‚Äã
            phonemes: Array [ "DH", "AH" ]
            ‚Äã
            visemes: Array [ "TH", "A" ]
            ‚Äã
            word: "the"
            */




        }

        const game = new Phaser.Game(config);

    </script>
</body>
</html>